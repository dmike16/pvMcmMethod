/* Name: main.c
 * Pourpose: main program for the PVSMCM method
 * Author: dmike
 */

#ifdef MTRACE
#include <mcheck.h>
#endif /* MTRACE */
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include "grid.h"
#include "u0.h"
#include "interpol_fun.h"
#include "eval_ic_on_grid.h"
#include "signal_dim.h"
#include "pvschema_core.h"
#include "vector_copy.h"

#define TOL 10E-07
#define _NLS 36
#define _check_time(a,b) if((a) > (b))(a)=(b)

static int
make_output_file(const float *buffer, char *name,int dimension)
{
  int i;
  int fd;
  int char_numb = 0;

  fd = open (name,O_WRONLY | O_CREAT | O_TRUNC,0666);

  if(fd == -1){
    perror("open");
    return 1;
  }

  FILE *arg = fdopen(fd,"w");
  
   for(i = 0; i < dimension; ++i)
     char_numb = fprintf(arg,"%.6f\n",buffer[i]);

  fclose(arg);
  
  return char_numb;

}

static void
autogenerate_octave_script(char *default_name,int dim_nod,float *first, float *last)
{
  int fd,i = 0;
  struct iovec vec[_NLS];
  struct iovec *vec_next;

  vec_next = vec;


  vec_next->iov_base = "% This file is auto-generated by the main program\n";
  vec_next->iov_len = strlen("% This file is auto-generated by the main program\n");
  ++vec_next;

  vec_next->iov_base = "% Don't change it\n";
  vec_next->iov_len = strlen("% Don't change it\n");
  ++vec_next;

  vec_next->iov_base = "clear\n";
  vec_next->iov_len = strlen("clear\n");
  ++vec_next;

  char _open[] = "f1 = fopen(\"/home/dmiky/Documenti/lavori_C_Cpp/tesi/arch/axesNodes.dat\");\n";
  vec_next->iov_base = _open;
  vec_next->iov_len = strlen(_open);
  ++vec_next;

  vec_next->iov_base = "for i=1:80\n";
  vec_next->iov_len = strlen("for i=1:80\n");
  ++vec_next;

  vec_next->iov_base = "x(i)=fscanf(f1,\"%f\",1);\n";
  vec_next->iov_len = strlen("x(i)=fscanf(f1,\"%f\",1);\n");
  ++vec_next;

  vec_next->iov_base = "y(i)=fscanf(f1,\"%f\",1);\n";
  vec_next->iov_len = strlen("y(i)=fscanf(f1,\"%f\",1);\n");
  ++vec_next;

  vec_next->iov_base = "z(i)=fscanf(f1,\"%f\",1);\n";
  vec_next->iov_len = strlen("z(i)=fscanf(f1,\"%f\",1);\n");
  ++vec_next;

  vec_next->iov_base = "end\n";
  vec_next->iov_len = strlen("end\n");
  ++vec_next;

  vec_next->iov_base = "fclose(f1);\n";
  vec_next->iov_len = strlen("fclose(f1);\n");
  ++vec_next;

 char *_open_2;
 _open_2 = malloc((56+strlen(default_name)+5)*sizeof(char));
 strcpy(_open_2,"f2=fopen(\"/home/dmiky/Documenti/lavori_C_Cpp/tesi/");
 strcat(_open_2,default_name);
 strcat(_open_2,"\");\n");
 vec_next->iov_base = _open_2;
 vec_next->iov_len = strlen(_open_2);
 ++vec_next;

  char _open_3[] = "f3 = fopen(\"/home/dmiky/Documenti/lavori_C_Cpp/tesi/arch/IC.dat\");\n";
  vec_next->iov_base = _open_3;
  vec_next->iov_len = strlen(_open_3);
  ++vec_next;

  vec_next->iov_base = "for i=1:80\n";
  vec_next->iov_len = strlen("for i=1:80\n");
  ++vec_next;

  vec_next->iov_base = "for j=1:80\n";
  vec_next->iov_len = strlen("for i=1:80\n");
  ++vec_next;


  vec_next->iov_base = "for k=1:80\n";
  vec_next->iov_len = strlen("for i=1:80\n");
  ++vec_next;

  vec_next->iov_base = "v(j,k,i)=fscanf(f2,\"%f\",1);\n";
  vec_next->iov_len = strlen("v(j,k,i)=fscanf(f2,\"%f\",1);\n");
  ++vec_next;

  vec_next->iov_base = "u(j,k,i)=fscanf(f3,\"%f\",1);\n";
  vec_next->iov_len = strlen("v(j,k,i)=fscanf(f2,\"%f\",1);\n");
  ++vec_next;

  vec_next->iov_base = "end\n";
  vec_next->iov_len = strlen("end\n");
  ++vec_next;

  vec_next->iov_base = "end\n";
  vec_next->iov_len = strlen("end\n");
  ++vec_next;

  vec_next->iov_base = "end\n";
  vec_next->iov_len = strlen("end\n");
  ++vec_next;

  vec_next->iov_base = "fclose(f2);\n";
  vec_next->iov_len = strlen("fclose(f2);\n");
  ++vec_next;

  vec_next->iov_base = "fclose(f3);\n";
  vec_next->iov_len = strlen("fclose(f3);\n");
  ++vec_next;

  vec_next->iov_base = "view(-38,20);\n";
  vec_next->iov_len = strlen("view(-38,20);\n");
  ++vec_next;

  vec_next->iov_base = "[X,Y,Z]=meshgrid(x,y,z);\n";
  vec_next->iov_len = strlen("[X,Y,Z]=meshgrid(x,y,z);\n");
  ++vec_next;

  vec_next->iov_base = "[faces,verts,c]=isosurface(X,Y,Z,u,1,Y);\n";
  vec_next->iov_len = strlen("[faces,verts,c]=isosurface(X,Y,Z,u,1,Y);\n");
  ++vec_next;

  vec_next->iov_base = "figure()\n";
  vec_next->iov_len = strlen("figure()\n");
  ++vec_next;

  vec_next->iov_base = "axis([-4.0,4.0,-4.0,4.0,-4.0,4.0]);\n";
  vec_next->iov_len = strlen("axis([-4.0,4.0,-4.0,4.0,-4.0,4.0]);\n");
  ++vec_next;

  char _patch[] = "p = patch(\"Faces\",faces,\"Vertices\",verts,\"FaceVertexCData\",c,...\n";
  vec_next->iov_base = _patch;
  vec_next->iov_len = strlen(_patch);
  ++vec_next;

  char _patch_2[] = "\"FaceColor\",\"interp\",\"EdgeColor\",\"blue\");\n";
  vec_next->iov_base = _patch_2;
  vec_next->iov_len = strlen(_patch_2);
  ++vec_next;

  vec_next->iov_base = "set(p,\"FaceLighting\",\"phong\");\n";
  vec_next->iov_len = strlen("set(p,\"FaceLighting\",\"phong\");\n");
  ++vec_next;

  vec_next->iov_base = "figure()\n";
  vec_next->iov_len = strlen("figure()\n");
  ++vec_next;

  vec_next->iov_base = "axis([-4.0,4.0,-4.0,4.0,-4.0,4.0]);\n";
  vec_next->iov_len = strlen("axis([-4.0,4.0,-4.0,4.0,-4.0,4.0]);\n");
  ++vec_next;

  vec_next->iov_base = "[faces,verts,c]=isosurface(X,Y,Z,v,1,Y);\n";
  vec_next->iov_len = strlen("[faces,verts,c]=isosurface(X,Y,Z,u,1,Y);\n");
  ++vec_next;

  char _patch_3[] = "p = patch(\"Faces\",faces,\"Vertices\",verts,\"FaceVertexCData\",c,...\n";
  vec_next->iov_base = _patch_3;
  vec_next->iov_len = strlen(_patch_3);
  ++vec_next;

  char _patch_4[] = "\"FaceColor\",\"interp\",\"EdgeColor\",\"blue\");\n";
  vec_next->iov_base = _patch_4;
  vec_next->iov_len = strlen(_patch_4);
  ++vec_next;

  vec_next->iov_base = "set(p,\"FaceLighting\",\"phong\");\n";
  vec_next->iov_len = strlen("set(p,\"FaceLighting\",\"phong\");\n");
  ++vec_next;

  fd = open("scripts/plotSurface.m", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  if(writev(fd,vec,_NLS) == -1){
    free(_open_2);
    close(fd);
    fprintf(stdout,"ERROR in CREAT OCTAVE SCRIPT\n");
    exit(1);}

  free(_open_2);
  close(fd);

}

int 
main(int argc, char *argv[])
{
  
#ifdef MTRACE
  mtrace();
#endif /* MTRACE */
  
  gridType g_nod;
  register int i;
  int dim_nod;
  int dim_space;
  float *first,*last,*step;
  float *nod_values,timeto,radius;

  // Check the correct usage of the programm	
  if (argc != 2 && argc != 3){
    fprintf(stderr,"usage: pvschema filename.dat output_filename.dat\n");
	  exit(EXIT_FAILURE);
  }
  
  // Read from the file
  int fd;
  struct stat file_info;
  char *data,*tmp;
  size_t length;
  
  fd = open (argv[1], O_RDONLY);
  fstat (fd,&file_info);
  length = file_info.st_size;
  
  data =  (char*) malloc (length);
  if((read (fd,data,length))== -1)
    fprintf(stderr,"Error in reading the file %s\n",argv[1]);
  close(fd);
  
  tmp = strtok(data,"\n");
  timeto = atof(tmp);
  tmp = strtok(NULL, "\n");
  dim_space = atoi(tmp);
  tmp = strtok(NULL, "\n");
  dim_nod = atoi(tmp);
  tmp = strtok(NULL,"\n");
  radius = atof(tmp);
  first = (float*) malloc(dim_space*sizeof(float));
  last = (float*) malloc(dim_space*sizeof(float));
  for (i = 0; (tmp = strtok(NULL, "\n")) != NULL ;i++){
    first[i]=(float)atof(tmp);
    last[i] = (float)atof(tmp = strtok(NULL,"\n"));
  }
  
  free((void*)data);
  //End read from the file
  
  step = malloc(dim_space*sizeof(float));
  for (i = 0; i < dim_space; i++)
    step[i] = (last[i] - first[i])/(dim_nod - 1.00f);
	
  // Print the values read from file
  fprintf(stdout,"********************************\n");
  fprintf(stdout,"Values read from %s :\n",argv[1]);
  fprintf(stdout,"Space R^%d\n""Number of nodes %d\n",dim_space,dim_nod);
  fprintf(stdout,"  Â°n        Axes Range         Spatial Step\n");
  for( i=0; i < dim_space; i++)
    fprintf(stdout," %3d      "      "  [%.2f,%.2f]        "
	    "DeltaX=%.2f\n",i+1,first[i],last[i],step[i]);
  fprintf(stdout,"TIMEOUT = %.2f\n",timeto);
  fprintf(stdout,"**********************************\n");
  fprintf(stdout,"Initial Condition (IC): paraboloide with radius %.2f\n",radius);
  
  // Create the grid in R^n
  int grid_size = (int) pow(dim_nod,dim_space); 
  g_nod = create_grid(dim_nod,dim_space,first,step);
  fprintf(stdout,"Grid Size: %d\n",grid_size);

  // Eval initial func on grid points	
  nod_values = eval_ic_on_grid(grid_size,dim_space,dim_nod,g_nod,u_0,radius);
  
  // Install handler for SIGDIM
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = handler_sigdim;
  sigaction(SIGDIM, &sa, NULL);
  
  // MCM method	
  float delta_t=step[0];
  float time = 0.0f;
  float *u_n_plus_one = malloc(grid_size*sizeof(float));
  float *u_n = malloc(grid_size*sizeof(float));
  char *default_name = NULL; 

  u_n = vector_copy(nod_values,u_n,grid_size);
  
  
  output_axes_nod(g_nod,dim_space,"arch/axesNodes.dat");
  fprintf(stdout," FILE CREATED \n");
  make_output_file(u_n,"arch/IC.dat",grid_size);
  fprintf(stdout," FILE CREATED \n");
    
  i = 0;
  for(;timeto;){
    fprintf(stdout,".");
    fflush(stdout);
    time += delta_t;
    _check_time(time,timeto);
    ++i;
    pvschema_core(dim_space,grid_size,dim_nod,u_n_plus_one,u_n,
		  step,delta_t,g_nod,first,last);
    if (fabs(timeto-time) <= TOL){
      if(argc == 2)
	default_name = "arch/dflMCMsolution.dat";
      else
	default_name = argv[2];
      if((make_output_file(u_n_plus_one,default_name,grid_size)) != -1)
	{
	  fprintf(stdout,"\nTempo %.2f reached in %d iter\n",timeto,i);
	  fprintf(stdout,"FILE CREATED \n");
	}
      else
	perror("make_output_file");
      break;
    }
    u_n = vector_copy(u_n_plus_one,u_n,grid_size);
  }

  //Generata octave script in order to plot the solution
  autogenerate_octave_script(default_name,dim_nod,first,last);     
  
  // Clean Allocated Memory
  clear_grid(g_nod,dim_space);
  free(step);
  free(first);
  free(last);
  free(nod_values);
  free(u_n);
  free(u_n_plus_one);
    
  return 0;
  
}
